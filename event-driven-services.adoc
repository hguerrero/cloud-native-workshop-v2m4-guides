== Lab2 - Creating Event-Driven/Reactive Services
:experimental:

Traditional microservice architecture is typically composed of many individual services with different functions. Each application service has many clients that need to communicate with the service for fetching data. It will become more complex to handle data streams because everything can be a stream of data such as end-user clicks, RESTful APIs, IoT devices generating data. And complexity rises when these services are running on hybrid or multi-cloud infrastructure.

In an event-driven architecture, we can treat data streams as *events* using reactive programming and distributed messaging. *Reactive programming* is an asynchronous programming paradigm concerned with data streams and the propagation of change. In the previous lab, we developed Inventory, Catalog, Shopping Cart and Order services with obvious interactions.

In this lab, we’ll change our shopping cart and order implementation and add a payment service as an Event-Driven/Reactive application in our cloud-native appliation architecture. These cloud-native applications will use Red Hat AMQ self-service as a messaging/streaming backbone. Red Hat AMQ enables developers to provision messaging when and where they need it through a browser console. 

Red Hat AMQ provides an OpenShift-based mechanism for delivering messaging as a managed service. With Red Hat AMQ, administrators can configure a cloud-native, multi-tenant messaging service either in the cloud or on premise. Developers can provision messaging using the Red Hat AMQ Console. Multiple development teams can provision the brokers and queues from the Console, without requiring each team to install, configure, deploy, maintain, or patch any software.

=== Goals of this lab

The goal is to develop advanced cloud-native applications on *Red Hat Runtimes* and deploy them on *OpenShift 4* including *AMQ* for event-driven capabilities. After this lab, you should end up with something like:

image::lab2-goal.png[goal, 700]

https://enmasse.io/[EnMasse] is the open source project that provides container images and operators for running the messaging infrastructure for https://www.redhat.com/en/technologies/jboss-middleware/amq?extIdCarryOver=true&sc_cid=701f2000001OH7TAAW[Red Hat AMQ,window=_blank] self-service messaging.

=== 1. Create an Address Space

Let's create an **Address Space**. Click *+Add* on the left, on the _From Catalog_ box on the project overview:

image::kafka-catalog.png[online, 700]

Type in `address` in the search box, and click on the *AddressSpace*:

image::online-catalog.png[AddressSpace, 700]

Click on *Create*:

image::online-create.png[create, 700]

Replace the content in the YAML editor with the following content:

[source,none,role="copypaste"]
----
apiVersion: enmasse.io/v1beta1
kind: AddressSpace
metadata:
  name: amq
spec:
  plan: standard-small
  type: standard
  endpoints:
    - name: messaging
      service: messaging
      expose:
        type: route
        routeServicePort: amqps
        routeTlsTermination: passthrough
      exports:
        - kind: ConfigMap
          name: amq-config
  authenticationService:
    name: none-authservice
----

Click on *Create* to start the deployment

image::addressspace-detail.png[details, 700]

The AMQ operator will check the new resource and will begin to prepare all required components. Wait for the *Address Space* to deploy the infrastructure until the status change _Active_. Click in the *amq* link to show the Overview Page.

image::addressspace-active.png[active, 700]

Click in the _YAML_ tab to enable the editor and scroll all the way down to the _Status_ sections to retrieve the console *externalHost* hostname value. This is the access to the webconsole to admin your events infrastructure.

image::addressspace-console.png[console, 700]

Open a new browser tab and use the hostname like this format *https://{{ externalHost }}* to open the AMQ web console. You will need to login with your username and password. 

[NOTE]
====
Note the use of _HTTPS_.
====

In the main AMQ web console screen, click on the *+ Create* button to start adding the required topics.

image::topic-create.png[newtopic, 700]

Fill in the name with *orders* and select the _topic_ type. Click *Next >* to move to the next screen.

image::topic-name.png[topicname, 700]

Keep the *Small Topic* plan selected and click *Next >*. 

image::topic-plan.png[topicplan, 700]

Finally click *Create* to submit the topic creation.

image::topic-summary.png[topicsummary, 700]

AMQ will start the deployment of the required messaging infrastructure to privision your topic.

image::topic-deploying.png[topicdeploying, 700]

Next, repeat the last couple steps to provision the second topic. Create the `payments` topic with the same type and plan than the _orders_ topic. 

Finally, repeat the last couple steps to provision the *queue* `invoices` with a _small-queue plan_. 

image::create-invoices.png[invoices-queue, 700]

A green check mark will show that the resources were successfully deployed.

image::topics.png[topics, 700]

*Well done!* You now have a running AMQ with two topics called `payments` and `orders` and a `invoices` queue.

=== 2. Develop and Deploy Payment Service

Our _Payment Service_ will offer online services for accepting electronic payments by a variety of payment methods including credit card or bank-based payments when orders are checked out in shopping cart. It doesn’t really do anything but will represent a payment microservice that will *process* online shopping orders as they are posted to our services.

In CodeReady Workspaces, expand *payment-service* directory.

image::codeready-workspace-payment-project.png[catalog, 700]

In this step, we will learn how our Quarkus-based payment service can use event-driven architecture to receive order events and _react_ with payment events.

Let's add Maven Dependencies using Quarkus Messaging extensions in CodeReady Workspaces Terminal:

[source,sh,role="copypaste"]
----
mvn quarkus:add-extension -Dextensions="amqp" -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/payment-service
----

This command imports the _reactive messaging_ extensions for Quarkus applications and provides all the necessary capabilities to integrate with AMQP brokers. Confirm your *pom.xml* looks as below, with the new dependencies:

[source,sh]
----
    ...
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-smallrye-reactive-messaging-amqp</artifactId>
      <version>${quarkus.version}</version>
    </dependency>
    ...
----

Let’s start by injecting an *Emitter* `producer` field which will be used to send messages. We’ll also add a `log` field so we can see debug messages later on.

Add this code to the `PaymentResource.java` file (in the `src/main/java/com/redhat/cloudnative` directory) at the `// TODO: Add Messaging Producer here` marker:

[source,none,role="copypaste"]
----
    @Inject
    @Channel("payments")
    private Emitter<String> producer;
----

Next, we need a method to handle incoming events.

Add this code at the `// TODO: Add handleCloudEvent method here` marker:

[source,none,role="copypaste"]
----
    public void handleCloudEvent(String cloudEventJson) {
        String orderId = "unknown";
        String paymentId = "" + ((int)(Math.floor(Math.random() * 100000)));

        try {
            log.info("received event: " + cloudEventJson);
            JsonObject event = new JsonObject(cloudEventJson);
            orderId = event.getString("orderId");
            String total = event.getString("total");
            String ccNumber = event.getString("ccNumber");
            String name = event.getString("name");

            // Only accept these cards
            if (ccNumber.startsWith("4") || ccNumber.startsWith("5") || ccNumber.startsWith("6")) {
                pass(orderId, paymentId, "Payment of " + total + " succeeded for " + name + " CC details: " + ccNumber);
            }
            else {
                fail(orderId, paymentId, "Invalid Credit Card: " + ccNumber);
            }
        } catch (Exception ex) {
             fail(orderId, paymentId, "Unknown error: " + ex.getMessage() + " for payment: " + cloudEventJson);
        }
    }
----

[NOTE]
====
Because we don't have a credit card validation service, we will only accept cards that start with 4,5, or 6.
====

Now we need to implement the pass() and fail() methods referenced above. These methods will send messages to the topic using our _producer_ field.

Add the following code to the `// TODO: Add pass method here` marker:

[source,none,role="copypaste"]
----
    private void pass(String orderId, String paymentId, String remarks) {
        JsonObject payload = new JsonObject();
        payload.put("orderId", orderId);
        payload.put("paymentId", paymentId);
        payload.put("remarks", remarks);
        payload.put("status", "COMPLETED");
        log.info("Sending payment success: " + payload.toString());
        producer.send(payload.toString());
    }
----

Add this code to the `// TODO: Add fail method here` marker:

[source,none,role="copypaste"]
----
    private void fail(String orderId, String paymentId, String remarks) {
        JsonObject payload = new JsonObject();
        payload.put("orderId", orderId);
        payload.put("paymentId", paymentId);
        payload.put("remarks", remarks);
        payload.put("status", "FAILED");
        log.info("Sending payment failure: " + payload.toString());
        producer.send( payload.toString());
    }
----

Next, add a method that will receive events from AMQ. We will use the MicroProfile reactive messaging API `@Incoming` annotation to do this.

Add this code to the `// TODO: Add consumer method here` marker:

[source,none,role="copypaste"]
----
    @Incoming("invoices")
    public CompletionStage<Void> onMessage(Message<String> message)
            throws IOException {

        log.info("Event message with value = {} arrived", message.getPayload());
        // fake processing time between 1 and 30 seconds
        long randomTime = Double.valueOf(1000 + (Math.random() * 29000)).longValue();
        vertx.setTimer(randomTime, l -> {
            handleCloudEvent(message.getPayload());    
        });
        
        return message.ack();
    }
----

[NOTE]
====
*vertx.setTimer();* will cause credit card _processing_ to take between 1 and 30 seconds, to simulate a real world processing time.
====


This method will consume events from the `orders` topic and call our `handleCloudEvent()` method. In module 5 of this workshop we’ll use Knative Events to handle the incoming stream. But for now we’ll use this method to listen to the topic.

Quarkus and it's extensions are configured by an `application.properties` file. Open this file (it is in the `src/main/resources` directory).

Replace the file content with the following values:

[source,properties,role="copypaste"]
----
# Outgoing stream
mp.messaging.outgoing.payments.connector=smallrye-amqp
mp.messaging.outgoing.payments.address=payments
mp.messaging.outgoing.payments.durable=false
mp.messaging.outgoing.payments.broadcast=true

# Incoming stream (unneeded when using Knative events)
mp.messaging.incoming.invoices.connector=smallrye-amqp
mp.messaging.incoming.invoices.durable=false
----

Build and deploy the project using the following command, which will use the maven plugin to deploy via CodeReady Workspaces Terminal:

[source,sh,role="copypaste"]
----
mvn clean package -DskipTests -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/payment-service
----

Create a build configuration for your application using OpenJDK base container image in OpenShift:

[source,sh,role="copypaste"]
----
oc new-build registry.access.redhat.com/redhat-openjdk-18/openjdk18-openshift:1.5 --binary --name=payment -l app=payment
----

Force update the OpenJDK image tags just in case they haven’t been imported yet:

[source,sh,role="copypaste"]
----
oc import-image openjdk18-openshift --all
----

Start and watch the build, which will take about minutes to complete:

[source,sh,role="copypaste"]
----
oc start-build payment --from-file=$CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/payment-service/target/payment-1.0-SNAPSHOT-runner.jar --follow
----

Deploy it as an OpenShift application after the build is done:

[source,sh,role="copypaste"]
----
oc new-app payment; oc expose svc/payment
----

To follow the external config practice of 12 factor applications we will inject the messaging endpoint `hostname` and `port` using the ConfigMap created by our _AddressSpace_ configuration.

[source,sh,role="copypaste"]
----
oc patch dc/payment -p '{ "spec": { "template": { "spec": { "containers": [ { "name": "payment", "env": [ { "name": "AMQP_HOST", "valueFrom": { "configMapKeyRef": { "name": "amq-config", "key": "service.host" } } }, { "name": "AMQP_PORT", "valueFrom": { "configMapKeyRef": { "name": "amq-config", "key": "service.port.amqp" } } } ] } ] } } } }' 
----

Finally, make sure it’s actually done rolling out. Visit the {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View, window=_blank] for the orders. Ensure you get the blue circles!

image::payment-topology.png[order, 700]

=== 3. Adding Events to Cart Service

By now we have added several microservices to operate on our retail shopping data. Quite often, other services or functions would need the data we are working with. e.g. once a user checks out, there are other services like an _Order Service_ and our _Payment Service_ that will need this information, and would most likely want to process further. So we will integrate our Cart service
with Events so that it can send an order message when a shopper checks out.

Add Maven Dependencies using Quarkus *Reactive Messaging* Extensions:

[source,sh,role="copypaste"]
----
mvn quarkus:add-extension -Dextensions="amqp" -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/cart-service
----

This will add the Messaging extension and APIs to our Cart service app.

Like our Payment service, add this code to the `// TODO: Add annotation of orders messaging configuration here` marker inside the `CartResource` class inside the `com.redhat.cloudnative` package:

[source,none,role="copypaste"]
----
    @Inject
    @Channel("orders")
    private Emitter<String> producer;
----

The `sendOrder()` method is quite simple, it takes the Order POJO as a param and serializes that into JSON to send over the topic. Replace the empty `sendOrder()` method with this code:

[source,none,role="copypaste"]
----
    private void sendOrder(Order order, String cartId) {
        order.setTotal(shoppingCartService.getShoppingCart(cartId).getCartTotal() + "");
        producer.send(Json.encode(order));
        log.info("Sent message: " + Json.encode(order));
    }
----

Now that we have those methods, Let'sadd a call to our `sendOrder()` method when we are checking out. Replace the code for `checkout()` with this code:

[source,none,role="copypaste"]
----
    @POST
    @Path("/checkout/{cartId}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(summary = "checkout")
    public ShoppingCart checkout(@PathParam("cartId") String cartId, Order order) {
        sendOrder(order, cartId);
        return shoppingCartService.checkout(cartId);
    }
----

Almost there! Next let’s add the configuration to our `application.properties` file (in the `src/main/resources` of the `cart-service` project):

[source,none,role="copypaste"]
----
mp.messaging.outgoing.orders.connector=smallrye-amqp
mp.messaging.outgoing.orders.address=orders
mp.messaging.outgoing.orders.durable=false
mp.messaging.outgoing.orders.broadcast=true
----

Re-package the _cart service_ using the following command, which will use the maven plugin to deploy via CodeReady Workspaces Terminal:

[source,sh,role="copypaste"]
----
mvn clean package -DskipTests -DskipTests -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/cart-service
----

Rebuild a container image based the cart artifact that we just packaged, which will take about minutes to complete:

[source,sh,role="copypaste"]
----
oc start-build cart --from-file $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/cart-service/target/*-runner.jar --follow
----

Configure the deployment to inject the messaging endpoint `hostname` and `port` using the ConfigMap created by our _AddressSpace_ configuration.

[source,sh,role="copypaste"]
----
oc patch dc/cart -p '{ "spec": { "template": { "spec": { "containers": [ { "name": "cart", "env": [ { "name": "AMQP_HOST", "valueFrom": { "configMapKeyRef": { "name": "amq-config", "key": "service.host" } } }, { "name": "AMQP_PORT", "valueFrom": { "configMapKeyRef": { "name": "amq-config", "key": "service.port.amqp" } } } ] } ] } } } }' 
----

The cart service will be redeployed automatically via https://docs.openshift.com/container-platform/4.1/applications/deployments/managing-deployment-processes.html#deployments-triggers_deployment-operations[OpenShift Deployment triggers,window=_blank] after it completes to build.

=== 4. Adding Events to Order Service

Like the *payments* service, our *order* service will listen for orders being placed, but will not process payments - instead the order service will merely record the orders and their states for eventual display in the UI. Let’s add this capability to the order service.

Add Maven Dependencies using Quarkus *Reactive Messaging* Extensions:

[source,sh,role="copypaste"]
----
mvn quarkus:add-extension -Dextensions="amqp" -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/order-service
----

This command generates a Maven project, importing the messaging extensions for Quarkus applications and provides all the necessary capabilities to integrate with the AMQ clusters and subscribe _payments_ topic and _orders_ topic. 

Create orders and payments consumer in _order service_ via creating a new Java class, `EventOrders.java` in `src/main/java/com/redhat/cloudnative` to consume messages from the _orders_ and _payments_ topic. Copy the following entire code into _EventOrders.java_.

[source,none,role="copypaste"]
----
package com.redhat.cloudnative;

import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Message;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.enterprise.context.ApplicationScoped;

import java.io.IOException;
import java.util.concurrent.CompletionStage;

import javax.inject.Inject;

import io.smallrye.reactive.messaging.annotations.Channel;
import io.smallrye.reactive.messaging.annotations.Emitter;
import io.vertx.core.json.Json;
import io.vertx.core.json.JsonObject;

@ApplicationScoped
public class EventOrders {

    private static final Logger LOG = LoggerFactory.getLogger(EventOrders.class);

    @Inject
    @Channel("invoices")
    private Emitter<String> producer;

    @Inject
    OrderService orderService;

    @Incoming("orders")
    public CompletionStage<Void> onMessage(Message<String> message)
            throws IOException {

        LOG.info("Event order message with value = {} arrived", message.getPayload());

        JsonObject orders = new JsonObject(message.getPayload());
        Order order = new Order();
        order.setOrderId(orders.getString("orderId"));
        order.setName(orders.getString("name"));
        order.setTotal(orders.getString("total"));
        order.setCcNumber(orders.getJsonObject("creditCard").getString("number"));
        order.setCcExp(orders.getJsonObject("creditCard").getString("expiration"));
        order.setBillingAddress(orders.getString("billingAddress"));
        order.setStatus("PROCESSING");
        
        producer.send(Json.encode(order));

        orderService.add(order);

        return message.ack();
    }

    @Incoming("payments")
    public CompletionStage<Void> onMessagePayments(Message<String> message)
            throws IOException {

        LOG.info("Event payment message with value = {} arrived", message.getPayload());

        JsonObject payments = new JsonObject(message.getPayload());
        orderService.updateStatus(payments.getString("orderId"), payments.getString("status"));

        return message.ack();
    }

}
----

Almost there; Next Let's add the configuration to our `src/main/resources/application.properties` file in the _order-service_ project:

[source,none,role="copypaste"]
----
# Outgoing stream
mp.messaging.outgoing.invoices.connector=smallrye-amqp
mp.messaging.outgoing.invoices.address=invoices
mp.messaging.outgoing.invoices.durable=false
mp.messaging.outgoing.invoices.broadcast=true

# Incoming payments topic messages
mp.messaging.incoming.payments.connector=smallrye-amqp
mp.messaging.incoming.payments.durable=false

# Enable CORS requests from browsers
quarkus.http.cors=true

# Incoming orders topic messages
mp.messaging.incoming.orders.connector=smallrye-amqp
mp.messaging.incoming.orders.durable=false
----

Re-package the order service using the following command, which will use the maven plugin to deploy via CodeReady Workspaces Terminal:

[source,sh,role="copypaste"]
----
mvn clean package -DskipTests -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/order-service
----

Rebuild a container image based the cart artifact that we just packaged, which will take about minutes to complete:

[source,sh,role="copypaste"]
----
oc start-build order --from-file=$CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/order-service/target/order-1.0-SNAPSHOT-runner.jar --follow
----

Configure the deployment to inject the messaging endpoint `hostname` and `port` using the ConfigMap created by our _AddressSpace_ configuration.

[source,sh,role="copypaste"]
----
oc patch dc/order -p '{ "spec": { "template": { "spec": { "containers": [ { "name": "order", "env": [ { "name": "AMQP_HOST", "valueFrom": { "configMapKeyRef": { "name": "amq-config", "key": "service.host" } } }, { "name": "AMQP_PORT", "valueFrom": { "configMapKeyRef": { "name": "amq-config", "key": "service.port.amqp" } } } ] } ] } } } }' 
----

The order service will be redeployed automatically via https://docs.openshift.com/container-platform/4.1/applications/deployments/managing-deployment-processes.html#deployments-triggers_deployment-operations[OpenShift Deployment triggers,window=_blank] after it completes to build.

Let’s confirm if the all services works correctly using `messaging` via coolstore GUI test.

=== 5. End to End Functional Testing

Let’s go shopping! Access the http://coolstore-ui-{{ USER_ID }}-cloudnativeapps.{{ ROUTE_SUBDOMAIN}}[Red Hat Cool Store, window=_blank]!

Add some cool items to your shopping cart in the following shopping scenarios:

[arabic]
. Add a _Red Hat Fedora_ to your cart by click on *Add to Cart*. You will see the `Success! Added!` message under the top menu.
+
image::add-to-cart.png[serverless, 1000]

[arabic, start=2]
. Go to the *Your Shopping Cart* tab and click on the *Checkout* button . Input the credit card information. The Card Info should be 16 digits and begin with the digit `4`. For example `4123987754646678`.
+
image::checkout.png[serverless, 1000]

[arabic, start=3]
. Input your Credit Card information to pay for the items:
+
image::input-cc-info.png[serverless, 1000]

[arabic, start=4]
. Confirm the _Payment Status_ of the your shopping items in the *All Orders* tab. It should be `Processing`.
+
image::payment-processing.png[serverless, 1000]

[arabic, start=5]
. After a few moments, reload the *All Orders* page to confirm that the Payment Status changed to `COMPLETED` or `FAILED`.
+
[Info]
====
If the status is still `Processing`, the order service is processing incoming event messages and storing them in MongoDB. Please reload the page a few times more.
====
+
image::payment-completedorfailed.png[serverless, 1000]

Remember the benefits of using an Event Driven Architecture? As a bonus task try to take down the payments service by scaling the deployment to zero. Replay the end to end testing and check that you won't see any errors because the service is down. Now bring back the service and check how it will process all the `invoices` waiting in the _queue_.

=== Summary

In this scenario we developed an _Event-Driven/Reactive_ cloud-native application to deal with data streams from the shopping cart service to the order service and payment service using _Red Hat AMQ_. We also used Quarkus and it's _Reactive Messaging extension_ to integrate the app with events.

In the end, we now have message-driven microservices for implementing reactive systems, where all the components interact using asynchronous messages passing. Most importantly, *Quarkus* is perfectly suited to implement event-driven microservices and reactive systems. Congratulations!
